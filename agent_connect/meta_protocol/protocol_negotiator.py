import logging
from enum import Enum
from typing import Dict, Any, Optional, Tuple, Callable, Awaitable
import json
from textwrap import dedent
import traceback

from pydantic import BaseModel, Field
from agent_connect.utils.llm.base_llm import BaseLLM

NEGOTIATION_INITIAL_SYSTEM_PROMPT = """
You are a protocol design expert. Your task is to design a communication protocol based on the given requirements and input/output descriptions.
The protocol should be clear, complete and follow standard conventions and industry best practices.

1. Please follow these requirements when designing the protocol:
- Request and response formats must use JSON and strictly follow RFC8259 specification
- Use JSON Schema (https://json-schema.org/draft/2020-12/schema) to describe request and response data formats. Need to mark which fields are required and which fields are optional.
- JSON design should follow standard specifications and best practices, with clear and concise field naming and schema descriptions
- Protocol flow should clearly and concisely describe the entire interaction process
- Error handling should cover exceptional cases, including but not limited to:
  * Timeout handling mechanism
  * Standard HTTP error codes
  * Custom error codes (if needed)
  * Error response format

2. Please reply in markdown format with the following sections and do not include any other content:
# Requirements
xxx
# Protocol Flow
xxx
# Data Format
## Request Format
xxx
## Response Format
xxx
# Error Handling
xxx

""" 

NEGOTIATION_EVALUATION_SYSTEM_PROMPT_FOR_PROVIDER = '''
You are a senior communication protocol negotiation expert. Your goal is to negotiate a protocol that both parties can accept for data communication. As a service provider, you aim to meet the service requester's needs as much as possible.

# Input Information
Your decision inputs include:
- requirement: Requirements are included in the Protocol content
- counterparty_latest_protocol: The latest protocol proposal from the counterparty
- your_previous_protocol: Your previous protocol proposal (if any)
- counterparty_modification_summary: Summary of modifications to the counterparty's protocol proposal (if your_previous_protocol exists)
- capability_info_history: List of previous capability information obtained from get_capability_info tool

# Decision Process
1. Compare the counterparty's protocol with your capabilities:
   - Review capability_info_history to understand your system limitations
   - Verify if you can meet all functional requirements
   - Check if the protocol design is implementable with your system
   
2. Evaluate data formats:
   - Verify if input data format is processable by your system
   - Verify if output data format can be generated by your system
   - Check for any incompatible or problematic fields
   
3. Review protocol design:
   - Assess if the protocol flow is feasible for implementation
   - Verify if error handling aligns with your system capabilities
   - Check if all edge cases can be handled by your system

4. Make decision:
   - ACCEPTED: if you can fully implement the protocol
   - REJECTED: if there are major capability mismatches
   - NEGOTIATING: if minor adjustments are needed (provide detailed modification suggestions)

# Decision Tools
You can use the get_capability_info tool to obtain your capability information, including:
- Whether you can meet the counterparty's requirements
- Whether the protocol data input is correct
- Whether the protocol data output is correct

# Output
Output format is NegotiationResult:
{
    "status": "negotiating/accepted/rejected",
    "candidate_protocol": "complete protocol content when status is negotiating, empty string otherwise",
    "modification_summary": "summary of your modifications or reasons for rejection"
}

Note: When status is "negotiating", candidate_protocol should contain the complete protocol content, not just the modifications. The modification_summary field is used to explain what changes were made and why.
'''


NEGOTIATION_EVALUATION_SYSTEM_PROMPT_FOR_REQUESTER = '''
You are a senior communication protocol negotiation expert. Your goal is to negotiate a protocol that both parties can accept for data communication. As a service requester, your goal is to have the service provider meet your requirements as much as possible.

# Input Information
Your decision inputs include:
- requirement: Your original requirements for the protocol
- input_description: Your expected input format description
- output_description: Your expected output format description
- counterparty_latest_protocol: The latest protocol proposal from the counterparty
- your_previous_protocol: Your previous protocol proposal (if any)
- counterparty_modification_summary: Summary of modifications to the counterparty's protocol proposal (if your_previous_protocol exists)

# Decision Process
1. Compare the counterparty's protocol with your original requirements:
   - Verify if all functional requirements are met
   - Check if the protocol design aligns with your specifications
   
2. Evaluate data formats:
   - Verify if input format matches your input_description
   - Verify if output format matches your output_description
   - Check for any missing or unnecessary fields
   
3. Review protocol design:
   - Assess if the protocol flow is logical and efficient
   - Verify error handling mechanisms
   - Check if all edge cases are properly handled

4. Make decision:
   - ACCEPTED: if the protocol fully meets your requirements
   - REJECTED: if there are major incompatibilities
   - NEGOTIATING: if minor modifications are needed (provide detailed modification suggestions)

# Output
Output format is NegotiationResult:
{
    "status": "negotiating/accepted/rejected",
    "candidate_protocol": "complete protocol content when status is negotiating, empty string otherwise",
    "modification_summary": "summary of your modifications or reasons for rejection"
}

Note: When status is "negotiating", candidate_protocol should contain the complete protocol content, not just the modifications. The modification_summary field is used to explain what changes were made and why.
'''

class NegotiationStatus(Enum):
    """Negotiation status enum"""
    NEGOTIATING = "negotiating"
    REJECTED = "rejected" 
    ACCEPTED = "accepted"

class NegotiationResult(BaseModel):
    """Protocol negotiation result model"""
    status: NegotiationStatus = Field(
        description="Current status of the protocol negotiation process, type: NegotiationStatus"
    )
    candidate_protocol: str = Field(
        default="",
        description="Complete content of the proposed protocol, included when status is negotiating, empty otherwise"
    )
    modification_summary: Optional[str] = Field(
        default="",
        description="Summary of modifications made to the counterparty's protocol in candidate_protocol, included when status is negotiating, empty otherwise"
    )

class NegotiatorRole(Enum):
    """Negotiator role enum"""
    PROVIDER = "provider"
    REQUESTER = "requester"

class NegotiationHistoryEntry:
    """Represents a single entry in the negotiation history.
    
    Attributes:
        round: The negotiation round number
        candidate_protocols: The protocol proposal for this round
        modification_summary: Summary of modifications made to previous proposal
    """
    def __init__(
        self,
        round: int,
        candidate_protocols: str,
        modification_summary: Optional[str] = None
    ):
        self.round = round
        self.candidate_protocols = candidate_protocols
        self.modification_summary = modification_summary

class ProtocolNegotiator:
    """Protocol negotiator that uses LLM to assist in protocol negotiation.
    
    This class handles the negotiation process between service providers and requesters
    to establish a mutually acceptable communication protocol.
    
    Attributes:
        llm: LLM instance used for protocol generation and evaluation
        requirement: Protocol requirements in natural language
        input_description: Expected input format description
        output_description: Expected output format description
        negotiation_round: Current round number in the negotiation process
        negotiation_history: List of previous protocol proposals and modifications
        role: Role in negotiation (PROVIDER or REQUESTER)
        capability_info_history: History of capability information responses
        get_capability_info_callback: Callback function for checking provider capabilities
    """
    def __init__(
        self, 
        llm: BaseLLM, 
        get_capability_info_callback: Optional[Callable[
            [str, str, str],  # requirement, input_description, output_description
            Awaitable[str]    # return type
        ]] = None
    ):
        """Initialize the protocol negotiator.
        
        Args:
            llm: Base LLM instance for generating and evaluating protocols
            get_capability_info_callback: Optional async callback function that checks
                provider's capability to implement a protocol. The callback takes three
                string parameters:
                - requirement: Protocol requirements description
                - input_description: Expected input format description
                - output_description: Expected output format description
                
                The callback should return a string containing capability assessment,
                including:
                - Whether the provider can meet the requirements
                - Whether the input format is processable
                - Whether the output format can be generated
                - Any limitations or constraints
                
                This callback is only used when acting as a provider.
        """
        self.llm: BaseLLM = llm
        self.requirement: str = ""
        self.input_description: str = ""
        self.output_description: str = ""
        self.negotiation_round: int = 0
        self.negotiation_history: list[NegotiationHistoryEntry] = []
        self.role: NegotiatorRole = NegotiatorRole.PROVIDER
        self.capability_info_history: list[str] = []
        self.get_capability_info_callback = get_capability_info_callback


    async def get_capability_info(self, requirement: str, 
                                 input_description: str, 
                                 output_description: str) -> str:
        """Get capability information from external callback function
        
        Args:
            requirement: Natural language description of protocol requirements
            input_description: Natural language description of expected input format
            output_description: Natural language description of expected output format
            
        Returns:
            Capability information as string, including:
            - Whether requirements can be met
            - Whether input data is correct, including field completeness, comprehensiveness, and type correctness
            - Whether output data is correct, including having expected field data, field type correctness, and presence of important fields
            
        Note:
            The callback function should return a string containing the capability assessment.
            If no callback is registered, returns empty string.
        """
        if self.get_capability_info_callback:
            try:
                return await self.get_capability_info_callback(
                    requirement, 
                    input_description, 
                    output_description
                )
            except Exception as e:
                logging.error(f"Get capability info callback failed: {str(e)}\nStack trace:\n{traceback.format_exc()}")
                return f"Error getting capability info: {str(e)}"
        return ""

    async def generate_initial_protocol(
        self,
        requirement: str,
        input_description: str,
        output_description: str
    ) -> Tuple[str, NegotiationStatus, int]:
        """Generate initial protocol proposal
        
        Returns:
            Tuple containing:
            - protocol: The generated protocol string
            - status: Negotiation status
            - round: Current negotiation round number
        """
        
        # Set role to REQUESTER when generating initial protocol
        self.role = NegotiatorRole.REQUESTER
        
        # Store parameters to instance variables
        self.requirement = requirement
        self.input_description = input_description 
        self.output_description = output_description
        
        # Initialize negotiation round
        self.negotiation_round = 1
        
        system_prompt = NEGOTIATION_INITIAL_SYSTEM_PROMPT
        
        user_prompt = dedent(f'''
            Please design a protocol with:

            --[ requirement ]--
            {requirement}
            --[END]--

            --[ input_description ]--
            {input_description}
            --[END]--

            --[ output_description ]--
            {output_description}
            --[END]--

            The protocol should be practical and implementable.
        ''').strip()

        try:
            protocol = await self.llm.async_generate_response(
                system_prompt=system_prompt,
                user_prompt=user_prompt
            )
            
            # Record negotiation history
            self.negotiation_history.append(NegotiationHistoryEntry(
                round=self.negotiation_round,
                candidate_protocols=protocol,
                modification_summary=None
            ))
            
            return protocol, NegotiationStatus.NEGOTIATING, self.negotiation_round
            
        except Exception as e:
            logging.error(f"Failed to generate initial protocol: {str(e)}\nStack trace:\n{traceback.format_exc()}")
            return "", NegotiationStatus.REJECTED, self.negotiation_round
        
    # TODO: Need to callback externally to check if it meets the other party's requirements
    async def evaluate_protocol_proposal(
        self,
        negotiation_status: NegotiationStatus,
        counterparty_round: int,
        candidate_protocols: Optional[str] = None,
        modification_summary: Optional[str] = None,
    ) -> Tuple[NegotiationResult, int]:
        """Evaluate protocol proposal based on role.
        
        Args:
            negotiation_status: Current negotiation status
            candidate_protocols: Protocol proposal to evaluate
            modification_summary: Optional summary of modifications
            counterparty_round: Round number from counterparty
            
        Returns:
            Tuple containing:
                - NegotiationResult: Updated status and details
                - int: Current negotiation round number
        """
        # Validate round number
        if counterparty_round is not None:
            expected_round = self.negotiation_round + 1
            if counterparty_round != expected_round:
                return NegotiationResult(
                    status=NegotiationStatus.REJECTED,
                    candidate_protocol="",
                    modification_summary=f"Invalid round number. Expected {expected_round}, got {counterparty_round}"
                ), self.negotiation_round
        
        # Handle terminal states
        if negotiation_status == NegotiationStatus.ACCEPTED:
            # Return the latest protocol from history if available
            return NegotiationResult(
                status=NegotiationStatus.ACCEPTED,
                candidate_protocol=self.negotiation_history[-1].candidate_protocols if self.negotiation_history else "",
                modification_summary=None
            ), self.negotiation_round
            
        if negotiation_status == NegotiationStatus.REJECTED:
            return NegotiationResult(
                status=NegotiationStatus.REJECTED,
                candidate_protocol="",
                modification_summary=None
            ), self.negotiation_round
        
        result : NegotiationResult = None
        if self.role == NegotiatorRole.PROVIDER:
            result = await self._evaluate_as_provider(
                candidate_protocols, modification_summary)
        else:
            result = await self._evaluate_as_requester(
                candidate_protocols, modification_summary)
        
        return result, self.negotiation_round

    async def _evaluate_as_provider(
        self,
        candidate_protocols: str,
        modification_summary: Optional[str] = None
    ) -> NegotiationResult:
        """Provider-specific protocol evaluation"""
        tools = [
            {
                "type": "function",
                "function": {
                    "name": "get_capability_info",
                    "description": "Get capability information to check if requirements can be met",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "requirement": {"type": "string", "description": "Protocol requirements"},
                            "input_description": {"type": "string", "description": "Expected input format description"},
                            "output_description": {"type": "string", "description": "Expected output format description"}
                        },
                        "required": ["requirement", "input_description", "output_description"]
                    }
                }
            }
        ]

        user_prompt = dedent(f'''
            Please evaluate this protocol proposal:

            --[ counterparty_latest_protocol ]--
            {candidate_protocols}
            --[END]--

            --[ your_previous_protocol ]--
            {self.negotiation_history[-1].candidate_protocols if self.negotiation_history else ""}
            --[END]--

            --[ counterparty_modification_summary ]--
            {modification_summary if modification_summary else 'None'}
            --[END]--

            --[ capability_info_history ]--
            {json.dumps(self.capability_info_history, indent=2)}
            --[END]--
        ''').strip()

        try:
            # Initialize base messages
            messages = [
                {"role": "system", "content": NEGOTIATION_EVALUATION_SYSTEM_PROMPT_FOR_PROVIDER},
                {"role": "user", "content": user_prompt}
            ]
            
            while True:
                completion = await self.llm.client.chat.completions.create(
                    model=self.llm.model_name,
                    messages=messages,
                    tools=tools,
                    tool_choice="auto",
                    response_format={"type": "json_object"}
                )
                
                assistant_message = completion.choices[0].message
                
                # Add assistant message to conversation history
                messages.append({
                    "role": "assistant",
                    "content": assistant_message.content,
                    "tool_calls": assistant_message.tool_calls
                })
                
                # If no tool calls, process the final response
                if not assistant_message.tool_calls:
                    break
                
                # Handle tool calls
                for tool_call in assistant_message.tool_calls:
                    if tool_call.function.name == "get_capability_info":
                        args = json.loads(tool_call.function.arguments)
                        capability_info = await self.get_capability_info(
                            args["requirement"],
                            args["input_description"],
                            args["output_description"]
                        )
                        self.capability_info_history.append(capability_info)
                        # Add tool response to messages
                        messages.append({
                            "role": "tool",
                            "content": str(capability_info),
                            "tool_call_id": tool_call.id
                        })

            self.negotiation_round += 1
            
            # Parse JSON response from assistant message
            if not assistant_message.content:
                raise ValueError("Received empty response from LLM")
            
            result_json = json.loads(assistant_message.content)
            result = NegotiationResult(
                status=NegotiationStatus(result_json["status"]),
                candidate_protocol=result_json["candidate_protocol"],
                modification_summary=result_json["modification_summary"]
            )

            if result.status == NegotiationStatus.NEGOTIATING:
                self.negotiation_history.append(NegotiationHistoryEntry(
                    round=self.negotiation_round,
                    candidate_protocols=result.candidate_protocol,
                    modification_summary=result.modification_summary
                ))
                
            return result
                
        except Exception as e:
            logging.error(f"Failed to evaluate protocol: {str(e)}\nStack trace:\n{traceback.format_exc()}")
            return NegotiationResult(
                status=NegotiationStatus.REJECTED,
                candidate_protocol="",
                modification_summary=f"Error during evaluation: {str(e)}"
            )
        
    async def _evaluate_as_requester(
        self,
        candidate_protocols: str,
        modification_summary: Optional[str] = None
    ) -> NegotiationResult:
        """Requester-specific protocol evaluation"""
        user_prompt = dedent(f'''
            Please evaluate this protocol proposal:

            --[ requirement ]--
            {self.requirement}
            --[END]--

            --[ input_description ]--
            {self.input_description}
            --[END]--

            --[ output_description ]--
            {self.output_description}
            --[END]--

            --[ counterparty_latest_protocol ]--
            {candidate_protocols}
            --[END]--

            --[ your_previous_protocol ]--
            {self.negotiation_history[-1].candidate_protocols if self.negotiation_history else ""}
            --[END]--

            --[ counterparty_modification_summary ]--
            {modification_summary if modification_summary else 'None'}
            --[END]--
        ''').strip()

        try:
            # Call LLM client directly
            response = await self.llm.client.chat.completions.create(
                model=self.llm.model_name,
                messages=[
                    {"role": "system", "content": NEGOTIATION_EVALUATION_SYSTEM_PROMPT_FOR_REQUESTER},
                    {"role": "user", "content": user_prompt}
                ],
                response_format={"type": "json_object"}
            )
            
            result_json = json.loads(response.choices[0].message.content)
            self.negotiation_round += 1
            
            result = NegotiationResult(
                status=NegotiationStatus(result_json["status"]),
                candidate_protocol=result_json["candidate_protocol"],
                modification_summary=result_json["modification_summary"]
            )

            if result.status == NegotiationStatus.NEGOTIATING:
                self.negotiation_history.append(NegotiationHistoryEntry(
                    round=self.negotiation_round,
                    candidate_protocols=result.candidate_protocol,
                    modification_summary=result.modification_summary
                ))
                
            return result

        except Exception as e:
            logging.error(f"Failed to evaluate protocol as requester: {str(e)}\nStack trace:\n{traceback.format_exc()}")
            return NegotiationResult(
                status=NegotiationStatus.REJECTED,
                candidate_protocol="",
                modification_summary=f"Error during evaluation: {str(e)}"
            )


